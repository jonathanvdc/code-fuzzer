using System;
using System.Collections.Generic;
using System.Linq;

namespace CodeFuzzer
{
    /// <summary>
    /// A grammar: a collection of token definitions, production rules, and
    /// a start symbol.
    /// </summary>
    public sealed class Grammar
    {
        public this()
        {
            this.rules = new Dictionary<string, HashSet<ProductionRule>>();
            this.tokenDefs = new Dictionary<string, ITokenDef>();
            this.triviaSymbols = new HashSet<string>();
            this.triviaSymList = new List<string>();
        }

        private Dictionary<string, HashSet<ProductionRule>> rules;
        private Dictionary<string, ITokenDef> tokenDefs;
        private HashSet<string> triviaSymbols;
        private List<string> triviaSymList;

        /// <summary>
        /// Gets the set of all nonterminals in the grammar.
        /// </summary>
        public IEnumerable<string> Nonterminals { get { return rules.Keys; } }

        /// <summary>
        /// Gets the set of all terminals in the grammar.
        /// </summary>
        public IEnumerable<string> Terminals { get { return tokenDefs.Keys; } }

        /// <summary>
        /// Gets the set of all terminals that represent trivia.
        /// </summary>
        public IEnumerable<string> TriviaTerminals { get { return triviaSymbols; } }

        /// <summary>
        /// Gets or sets the start symbol for the grammar.
        /// </summary>
        public string StartSymbol { get; set; }

        /// <summary>
        /// Tests if the grammar has a non-null start symbol.
        /// </summary>
        public bool HasStartSymbol { get { return StartSymbol != null; } }

        /// <summary>
        /// Gets the set of all symbols in the grammar, i.e., the union of the
        /// sets of terminals and nonterminals.
        /// </summary>
        public IEnumerable<string> Symbols
        {
            get { return Enumerable.Union<string>(Terminals, Nonterminals); }
        }

        /// <summary>
        /// Tests if the grammar defines the given terminal.
        /// </summary>
        public bool DefinesTerminal(string Terminal)
        {
            return tokenDefs.ContainsKey(Terminal);
        }

        /// <summary>
        /// Tests if the grammar defines the given nonterminal.
        /// </summary>
        public bool DefinesNonterminal(string Nonterminal)
        {
            return rules.ContainsKey(Nonterminal);
        }

        /// <summary>
        /// Tests if the grammar defines the given symbol.
        /// </summary>
        public bool DefinesSymbol(string Symbol)
        {
            return DefinesTerminal(Symbol) || DefinesNonterminal(Symbol);
        }

        /// <summary>
        /// Checks if the given terminal is a trivia symbol.
        /// </summary>
        public bool IsTriviaSymbol(string Terminal)
        {
            return triviaSymbols.Contains(Terminal);
        }

        /// <summary>
        /// Gets the set of all production rules for the given nonterminal.
        /// </summary>
        public IEnumerable<ProductionRule> GetProductionRules(string Nonterminal)
        {
            return rules[Nonterminal];
        }

        /// <summary>
        /// Gets the set of all production rules in the grammar.
        /// </summary>
        public IEnumerable<ProductionRule> GetProductionRules()
        {
            var results = new List<ProductionRule>();
            foreach (var item in rules)
                results.AddRange(item.Value);
            return results;
        }

        /// <summary>
        /// Adds the given production rule to the grammar. If the rule was
        /// already present, then 'false' is returned. Otherwise, 'true' is
        /// returned.
        /// </summary>
        public bool AddProductionRule(ProductionRule Rule)
        {
            if (!rules.ContainsKey(Rule.Symbol))
                rules.Add(Rule.Symbol, new HashSet<ProductionRule>());

            return rules[Rule.Symbol].Add(Rule);
        }

        /// <summary>
        /// Gets the token definition for the given terminal.
        /// </summary>
        public ITokenDef GetTokenDef(string Terminal)
        {
            return tokenDefs[Terminal];
        }

        /// <summary>
        /// (Re-)defines the given terminal as the given token definition.
        /// </summary>
        public void DefineToken(string Terminal, ITokenDef Def)
        {
            tokenDefs[Terminal] = Def;
        }

        /// <summary>
        /// Marks the given terminal as trivia.
        /// </summary>
        public bool MarkTrivia(string Terminal)
        {
            if (triviaSymbols.Add(Terminal))
                triviaSymList.Add(Terminal);
        }

        /// <summary>
        /// Randomly generate a token that belongs to the given terminal,
        /// without any trivia.
        /// </summary>>
        public Token GenerateTokenWithoutTrivia(string Terminal, Random Rand)
        {
            return new Token(Terminal, GetTokenDef(Terminal).Generate(Rand));
        }

        /// <summary>
        /// Picks a random trivia symbol, and generates a token for that symbol.
        /// If no trivia symbols have been defined for this grammar, then 'null'
        /// is returned.
        /// </summary>
        public Token GenerateSimpleTriviaToken(Random Rand)
        {
            if (triviaSymList.Count == 0)
                return null;
            else
                return GenerateTokenWithoutTrivia(
                    Helpers.PickRandomElement<string>(triviaSymList, Rand),
                    Rand);
        }

        /// <summary>
        /// Generates a trivia token that contains the given number of nested
        /// leading trivia tokens. If no trivia symbols have been defined
        /// for this grammar, then 'null' is returned.
        /// </summary>
        public Token GenerateNestedTriviaToken(Random Rand, int Depth)
        {
            var simpleToken = GenerateSimpleTriviaToken(Rand);
            if (Depth <= 0 || simpleToken == null)
                return simpleToken;
            else
                return simpleToken.WithLeadingTrivia(
                    GenerateNestedTriviaToken(Rand, Depth - 1));
        }

        /// <summary>
        /// Generates a token that belongs to the given terminal, with trivia.
        /// </summary>
        public Token GenerateTokenWithTrivia(
            string Terminal, Random Rand,
            int LeadingTriviaDepth, int TrailingTriviaDepth)
        {
            return GenerateTokenWithoutTrivia(Terminal, Rand)
                .WithLeadingTrivia(GenerateNestedTriviaToken(Rand, LeadingTriviaDepth))
                .WithLeadingTrivia(GenerateNestedTriviaToken(Rand, TrailingTriviaDepth));
        }
    }
}
